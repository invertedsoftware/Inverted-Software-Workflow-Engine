{"name":"Inverted software workflow engine (codename Gazelle)","tagline":"Project Gazelle. an Enterprise Processing Workflow Engine","body":"**Gazelle** is a dependency injection based workflow engine. The engine uses a workflow XML configuration file in order to decide what set of processing steps to execute on a request. The system is logically separated into producers and consumers. The producers produce a work request. They signal the framework that they need something done sometime in the future. They request work to be done and they don't sit around waiting for it. They simply continue executing code. For example: a producer can request a sales report to be calculated and emailed to the sales manager. The report might be generated on another process, another computer or even in another data center. The producer is unaware of when and where the report is generated, it simply knows a report will be emailed and continues on with its tasks. A consumer constantly listens to work requests. The request can come in from different channels. If parts of the systems are down, the consumer simply stops listening to work requests from it until it is up again. When a work request comes in, a consumer inspects the type of work to be done. It then reads the workflow for this type of request and executes the work steps sequentially or in parallel.\r\n\r\n![](http://galratner.com/cfs-filesystemfile.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/net/6562.FrameworkWorkload.jpg)\r\n\r\nA consumer can notify the system when it is done or when an error occurs and a producer can choose to wait for a result and act on it. The open release does not include the real time work report or the producer wait system and if you need them you will have to write the code in your own app. It’s easy and takes less than ten lines of code.\r\n\r\n```XML\r\n<Workflow>\r\n\t<Job Name=\"ExampleJob\" MessageClass=\"ExampleMessage\" NotifyComplete=\"true\" MaxRunTimeMilliseconds=\"36000000\">\r\n\t\t<Queues>\r\n\t\t\t<Queue MessageQueue=\".\\Private$\\WorkflowEngine.ExampleJob\" ErrorQueue=\".\\Private$\\WorkflowEngine.ExampleJobError\" PoisonQueue=\".\\Private$\\WorkflowEngine.ExampleJobPoison\" CompletedQueue=\".\\Private$\\WorkflowEngine.ExampleJobComplete\" MessageQueueType=\"Transactional\"></Queue>\r\n\t\t\t<Queue MessageQueue=\".\\Private$\\WorkflowEngine.ExampleJobBackup\" ErrorQueue=\".\\Private$\\WorkflowEngine.ExampleJobErrorBackup\" PoisonQueue=\".\\Private$\\WorkflowEngine.ExampleJobPoisonBackup\" CompletedQueue=\".\\Private$\\WorkflowEngine.ExampleJobCompleteBackup\" MessageQueueType=\"Transactional\"></Queue>\r\n\t\t</Queues>\r\n\t\t<Steps>\r\n\t\t\t<Step Name=\"CopyFiles\" Group=\"group1\" InvokeClass=\"InvertedSoftware.WorkflowEngine.Steps.CopyFiles\" OnError=\"Exit\" RetryTimes=\"3\" WaitBetweenRetriesMilliseconds=\"5000\" RunMode=\"STA\" DependsOn=\"\" DependsOnGroup=\"\" WaitForDependsOnMilliseconds=\"\" RunAsDomain=\"\" RunAsUser=\"\" RunAsPassword=\"\"></Step>\r\n\t\t\t<Step Name=\"RenameFiles\" Group=\"group1\" InvokeClass=\"InvertedSoftware.WorkflowEngine.Steps.RenameFiles\" OnError=\"Exit\" RetryTimes=\"3\" WaitBetweenRetriesMilliseconds=\"5000\" RunMode=\"STA\" DependsOn=\"CopyFiles\" DependsOnGroup=\"\" WaitForDependsOnMilliseconds=\"\" RunAsDomain=\"\" RunAsUser=\"\" RunAsPassword=\"\"></Step>\r\n\t\t</Steps>\r\n\t</Job>\r\n</Workflow>\r\n```\r\n\r\n**Calling the framework:**\r\nIn order for a producer to request a job execution it needs to call the FrameworkManager in code. A call looks like this:\r\n\r\n```C#\r\nExampleMessage message = new ExampleMessage()\r\n{\r\n\t\tCopyFilesFrom = @\"C:\\FrameworkTest\\Source\\\",\r\n\t\tCopyFilesTo = @\"C:\\FrameworkTest\\Destination\\\"\r\n};\r\nFrameworkManager.AddFrameworkJob(JobName, message);\r\n```\r\n\r\nA framework consumer must be started with a specific job name. Since the framework thread will block as long as the framework is running it is a good idea to start the framework in its own thread. The consumer’s code looks like this:\r\n\r\n```C#\r\nTask.Factory.StartNew(() =>\r\n{\r\n\ttry\r\n\t{\r\n\t\tframeworkProcessor.StartFramework(JobName);\r\n\t}\r\n\tcatch (Exception ex)\r\n\t{\r\n\t\tMessageBox.Show(\"Framework Error.\" + ex.Message);\r\n\t}\r\n});\r\n```\r\n**Adding steps:**\r\nYou can add as many steps as you like. Please see the example steps I have added to the steps folder. I always try and keep all the steps in the step folder as good practice. You can think about the steps as residing at the top of your business layer. They have access to the rest of the business layer and to the data layer (if you are doing layer cross cutting). Each step needs to implement the IStep interface and define a RunStep method accepting an IWorkflowMessage. RunStep will be the first method to be invoked in the step by the framework.\r\n\r\n```C#\r\ninternal class CopyFiles : IStep\r\n\t{\r\n\t\t/// <summary>\r\n\t\t/// The method executed by the framework\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"message\"></param>\r\n\t\tpublic void RunStep(IWorkflowMessage message)\r\n\t\t{\r\n\t\t\tExampleMessage myMessage = message as ExampleMessage;\r\n\t\t\tif (myMessage == null)\r\n\t\t\t\tthrow new WorkflowStepException(\"IWorkflowMessage is of the wrong type\");\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tParallel.ForEach<string>(Directory.EnumerateFiles(myMessage.CopyFilesFrom, \"*\"), f =>\r\n\t\t\t\t{\r\n\t\t\t\t\tFile.Copy(f, myMessage.CopyFilesTo + @\"\\\" + Path.GetFileName(f), true);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tcatch (Exception e)\r\n\t\t\t{\r\n\t\t\t\tthrow new WorkflowStepException(e.Message, e);\r\n\t\t\t}\r\n\t\t}\r\n\t\t/// <summary>\r\n\t\t/// Dispose\r\n\t\t/// </summary>\r\n\t\tpublic void Dispose()\r\n\t\t{\r\n\t\t\tGC.SuppressFinalize(this);\r\n\t\t}\r\n\t}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}